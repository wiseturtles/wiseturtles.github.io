<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wise Turtles - linux-commands</title><link href="http://blog.wiseturtles.com/" rel="alternate"></link><link href="http://blog.wiseturtles.com/feeds/linux-commands.atom.xml" rel="self"></link><id>http://blog.wiseturtles.com/</id><updated>2015-11-23T14:21:00+08:00</updated><entry><title>top</title><link href="http://blog.wiseturtles.com/posts/linux-top.html" rel="alternate"></link><published>2015-11-23T14:21:00+08:00</published><updated>2015-11-23T14:21:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-11-23:/posts/linux-top.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;top&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;top命令的具体就不解释了，记录一些实用的命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# redis用户此时所使用的内存总数&lt;/span&gt;
&lt;span class="c1"&gt;# 这里的内存使用&lt;/span&gt;
top -bn1 -u redis &lt;span class="p"&gt;|&lt;/span&gt;  awk &lt;span class="s1"&gt;&amp;#39;{mem += $10} END {print mem}&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# 查看服务器所有进程的内容使用总数&lt;/span&gt;
&lt;span class="c1"&gt;# 结果可能大于100%，反应出目前机器内容可用较少, 具体解释可以参考&lt;/span&gt;
&lt;span class="c1"&gt;# http://serverfault.com/questions/471757/sum-of-memory-of-few-processes-in-top-is-greater-than-100&lt;/span&gt;
$ top -bn1 &lt;span class="p"&gt;|&lt;/span&gt;  awk &lt;span class="s1"&gt;&amp;#39;{mem += $10} END {print mem}&amp;#39;&lt;/span&gt;
135.6
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="command"></category><category term="top"></category></entry><entry><title>Linux远程文件拷贝</title><link href="http://blog.wiseturtles.com/posts/copy-remote-host-file.html" rel="alternate"></link><published>2015-11-11T10:12:00+08:00</published><updated>2015-11-11T10:12:00+08:00</updated><author><name>ox0spy</name></author><id>tag:blog.wiseturtles.com,2015-11-11:/posts/copy-remote-host-file.html</id><summary type="html">&lt;p&gt;Linux远程文件拷贝&lt;/p&gt;</summary><content type="html">&lt;p&gt;我们经常会碰到从一个主机上拷贝文件到其他主机，本文汇总下常用方法。&lt;/p&gt;
&lt;h2&gt;ssh&lt;/h2&gt;
&lt;p&gt;提到远程文件拷贝，大家肯定首先想到的是ssh。(啥? 你想到的是ftp??&amp;nbsp;搭建个ftp好麻烦&amp;#8230;)&lt;/p&gt;
&lt;p&gt;避免输入用户密码，可以先运行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh-copy-id &amp;lt;user@remote-host&amp;gt;  &lt;span class="c1"&gt;# 输入密码，它会将你的key(~/.ssh/id_rsa.pub)添加到remote-host:~user/.ssh/authorized_keys&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过scp做文件拷贝:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ scp &lt;span class="o"&gt;[&lt;/span&gt;-r&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-P port&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt;your-local-file&amp;gt; &lt;span class="o"&gt;[]&lt;/span&gt;&amp;lt;user&amp;gt;@&lt;span class="o"&gt;]&lt;/span&gt;&amp;lt;remote-host&amp;gt;:&amp;lt;remote-file-path&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果网络比较慢可以先压缩再拷贝:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh user@remote-host &lt;span class="s2"&gt;&amp;quot;tar zcf - /file/path/to/copy&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tar zxf - -C /file/path/to/receive  &lt;span class="c1"&gt;# 从remote-host拷贝文件回来&lt;/span&gt;
$ tar zcf - /file/path/to/copy &lt;span class="p"&gt;|&lt;/span&gt; ssh user@remote-host &lt;span class="s2"&gt;&amp;quot;tar zxf - -C /file/path/to/receive&amp;quot;&lt;/span&gt;  &lt;span class="c1"&gt;# 将本地文件拷贝到remote-host&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span class="caps"&gt;HTTP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;也可以通过&lt;span class="caps"&gt;HTTP&lt;/span&gt;协议拷贝，如果本地正好有nginx/apache，ln -s 创建个软链接到外部可以访问的路径，从其它机器可以通过wget下载。
但，不是所有机器都装了nginx/apache，可以通过Python自带模块快速启动一个&lt;span class="caps"&gt;HTTP&lt;/span&gt; Simple&amp;nbsp;Server。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ python -mSimpleHTTPServer  &lt;span class="c1"&gt;# 默认监听8000端口，你当然可以自己指定端口&lt;/span&gt;
$ python -mSimpleHTTPServer &lt;span class="m"&gt;8888&lt;/span&gt;  &lt;span class="c1"&gt;# 指定监听端口为8888&lt;/span&gt;
$ wget listen-ip:port/&amp;lt;file/path&amp;gt; &lt;span class="c1"&gt;# 从其它主机拷贝文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;既然已经有了&lt;span class="caps"&gt;HTTP&lt;/span&gt;&amp;nbsp;Server，你当然可以通过浏览器访问了。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;HTTP&lt;/span&gt;完全可以支持断点续传，wget -c&amp;nbsp;就可以。&lt;/p&gt;
&lt;h2&gt;rsync&lt;/h2&gt;
&lt;p&gt;大家可能都体会过scp传输过程中，网络、主机异常导致必须重新传，小文件、网络快还好，不然真的想打人。&amp;nbsp;你一定想如果可以断点续传就好了，rsync可以完成你的心愿。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rsync -P --rsh&lt;span class="o"&gt;=&lt;/span&gt;ssh --progress &amp;lt;your-local-file&amp;gt; user@remote-host:&amp;lt;receive-file-path&amp;gt;
$ rsync -P -v -e ssh &amp;lt;local-file&amp;gt; user@remote-host:receive-file-path  &lt;span class="c1"&gt;# 本地同步文件到remote-host&lt;/span&gt;
$ rsync -P -v -e ssh user@remote-host:receive-file-path &amp;lt;local-file-path&amp;gt;  &lt;span class="c1"&gt;# remote-host文件同步到本地&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;rsync功能强大，以后再补充。&lt;/p&gt;
&lt;h2&gt;zsync&lt;/h2&gt;
&lt;p&gt;先安装后看文档吧，基于&lt;span class="caps"&gt;HTTP&lt;/span&gt;的rsync，使用有一定限制，必须服务端有 .zsync&amp;nbsp;才行。优点是速度非常快。&lt;/p&gt;</content><category term="Linux"></category><category term="ssh"></category><category term="sync"></category><category term="python"></category><category term="tar"></category></entry><entry><title>netstat</title><link href="http://blog.wiseturtles.com/posts/linux-netstat.html" rel="alternate"></link><published>2015-01-14T10:35:00+08:00</published><updated>2015-01-14T10:35:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-14:/posts/linux-netstat.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;netstat&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html"&gt;http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.binarytides.com/linux-netstat-command-examples/"&gt;http://www.binarytides.com/linux-netstat-command-examples/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用&lt;/h2&gt;
&lt;p&gt;Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态
(Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等&amp;nbsp;等。&lt;/p&gt;
&lt;h2&gt;输出信息含义&lt;/h2&gt;
&lt;p&gt;执行netstat后，其输出结果为&lt;/p&gt;
&lt;pre&gt;
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED
tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED
tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED
tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED
tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE

Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags Type State I-Node Path
unix 1 [ ] STREAM CONNECTED 16178 @000000dd
unix 1 [ ] STREAM CONNECTED 16176 @000000dc
unix 9 [ ] DGRAM 5292 /dev/log
unix 1 [ ] STREAM CONNECTED 16182 @000000df
&lt;/pre&gt;

&lt;p&gt;从整体上看，netstat的输出结果可以分为两个部分：&lt;/p&gt;
&lt;p&gt;一个是Active Internet connections，称为有源&lt;span class="caps"&gt;TCP&lt;/span&gt;连接，其中&amp;#8221;Recv-Q&amp;#8221;和&amp;#8221;Send-Q&amp;#8221;指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。&lt;/p&gt;
&lt;p&gt;另一个是Active &lt;span class="caps"&gt;UNIX&lt;/span&gt; domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。&amp;nbsp;Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。&lt;/p&gt;
&lt;h2&gt;常见参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;-a&amp;nbsp;(all)显示所有监听和未监听的连接&lt;/li&gt;
&lt;li&gt;-t&amp;nbsp;(tcp)仅显示tcp相关选项&lt;/li&gt;
&lt;li&gt;-u&amp;nbsp;(udp)仅显示udp相关选项&lt;/li&gt;
&lt;li&gt;-n&amp;nbsp;拒绝显示别名，能显示数字的全部转化成数字。&lt;/li&gt;
&lt;li&gt;-l 仅列出有在 Listen (监听) 的服務状态&amp;nbsp;*&lt;/li&gt;
&lt;li&gt;-p&amp;nbsp;显示建立相关链接的程序名&lt;/li&gt;
&lt;li&gt;-r&amp;nbsp;显示路由信息，路由表&lt;/li&gt;
&lt;li&gt;-e&amp;nbsp;显示扩展信息，例如uid等&lt;/li&gt;
&lt;li&gt;-s&amp;nbsp;按各个协议进行统计&lt;/li&gt;
&lt;li&gt;-c&amp;nbsp;每隔一个固定时间，执行该netstat命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：&lt;span class="caps"&gt;LISTEN&lt;/span&gt;和&lt;span class="caps"&gt;LISTENING&lt;/span&gt;的状态只有用-a或者-l才能看到&lt;/p&gt;
&lt;h2&gt;实用命令实例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 列出所有连接（包括监听和未监听的)&lt;/span&gt;
$ netstat -a

&lt;span class="c1"&gt;# 列出所有tcp连接&lt;/span&gt;
$ netstat -at

&lt;span class="c1"&gt;# 列出所有udp连接&lt;/span&gt;
$ netstat -au

&lt;span class="c1"&gt;# 默认情况下，netstat命令会做一个reverse dns lookup去查找连接的ip&lt;/span&gt;
&lt;span class="c1"&gt;# 对应的主机名，这会降低输出速度，如果不需要，可以使用-n&lt;/span&gt;
&lt;span class="c1"&gt;# 在netstat输出中不显示主机，端口和用户名(host, port or user)&lt;/span&gt;
$ netstat -an

&lt;span class="c1"&gt;# 列出所有处于监听状态的&lt;/span&gt;
&lt;span class="c1"&gt;# -l选项不要与-a同时使用，不然也会列出未监听状态的连接&lt;/span&gt;
$ netstat -l

&lt;span class="c1"&gt;# 列出所有监听状态的tcp连击&lt;/span&gt;
$ netstat -lt

&lt;span class="c1"&gt;# 列出所有监听状态的udp连击&lt;/span&gt;
$ netstat -lu

&lt;span class="c1"&gt;# 列出所有的unix连接&lt;/span&gt;
$ netstat -lx

&lt;span class="c1"&gt;# 在netstat输出中显示PID和进程名称(-p),用户名(-e)&lt;/span&gt;
&lt;span class="c1"&gt;# -p使用需要root权限,不然无法获取PID&lt;/span&gt;
$ sudo netstat -ltpe
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode       PID/Program name
tcp        &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; localhost:5037          *:*                     LISTEN      linliang   &lt;span class="m"&gt;4530492&lt;/span&gt;     11684/adb
tcp        &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; localhost:63342         *:*                     LISTEN      linliang   &lt;span class="m"&gt;10952269&lt;/span&gt;    6663/java
tcp        &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; localhost:9200          *:*                     LISTEN      linliang   &lt;span class="m"&gt;10361577&lt;/span&gt;    12461/ssh
tcp        &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; *:http                  *:*                     LISTEN      root       &lt;span class="m"&gt;12810&lt;/span&gt;       1344/nginx
tcp        &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; localhost:domain        *:*                     LISTEN      root       &lt;span class="m"&gt;683&lt;/span&gt;         1481/dnsmasq

&lt;span class="c1"&gt;# 上面的命令总如果使用-n,将会显示用户UID，而不是用户名&lt;/span&gt;

&lt;span class="c1"&gt;# 列出所有的网络统计信息&lt;/span&gt;
$ netstat -s
Ip:
&lt;span class="m"&gt;14989101&lt;/span&gt; total packets received
&lt;span class="m"&gt;0&lt;/span&gt; forwarded
&lt;span class="m"&gt;0&lt;/span&gt; incoming packets discarded
&lt;span class="m"&gt;14986294&lt;/span&gt; incoming packets delivered
&lt;span class="m"&gt;11643610&lt;/span&gt; requests sent out
Icmp:
    &lt;span class="m"&gt;6034&lt;/span&gt; ICMP messages received
    &lt;span class="m"&gt;71&lt;/span&gt; input ICMP message failed.
    ICMP input histogram:
        destination unreachable: 5774
        timeout in transit: 106
        &lt;span class="nb"&gt;echo&lt;/span&gt; replies: 154
    &lt;span class="m"&gt;6882&lt;/span&gt; ICMP messages sent
    &lt;span class="m"&gt;0&lt;/span&gt; ICMP messages failed
    ICMP output histogram:
....

&lt;span class="c1"&gt;# 显示TCP或UDP连接的统计信息&lt;/span&gt;
$ netstat -st
$ netstat -su

&lt;span class="c1"&gt;# 显示kernel的路由信息(-r)&lt;/span&gt;
$ netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         172.26.50.1     0.0.0.0         UG        &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt; eth1
169.254.0.0     0.0.0.0         255.255.0.0     U         &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt; eth1
172.26.50.0     0.0.0.0         255.255.255.0   U         &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt; eth1
192.168.56.0    0.0.0.0         255.255.255.0   U         &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt; vboxnet0

&lt;span class="c1"&gt;# 打印网络接口(-i)&lt;/span&gt;
$ netstat -i
Kernel Interface table
Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth1       &lt;span class="m"&gt;1500&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;10650979&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;10656895&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; BMRU
lo        &lt;span class="m"&gt;65536&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;   &lt;span class="m"&gt;5095802&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;       &lt;span class="m"&gt;5095802&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; LRU
vboxnet0   &lt;span class="m"&gt;1500&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;         &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;1505&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="m"&gt;0&lt;/span&gt; BMRU

&lt;span class="c1"&gt;# 上面的输出比较原始，为了获取友好输出，可以加上(-e)&lt;/span&gt;
&lt;span class="c1"&gt;# 达到与ifconfig命令类似的效果&lt;/span&gt;
$ netstat -ie
Kernel Interface table
eth1      Link encap:Ethernet  HWaddr 44:39:c4:8d:d9:64
        inet addr:172.26.50.13  Bcast:172.26.50.255  Mask:255.255.255.0
        inet6 addr: fe80::4639:c4ff:fe8d:d964/64 Scope:Link
        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
        RX packets:10651112 errors:0 dropped:0 overruns:0 frame:0
        TX packets:10656940 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:1000
        RX bytes:6607723134 &lt;span class="o"&gt;(&lt;/span&gt;6.6 GB&lt;span class="o"&gt;)&lt;/span&gt;  TX bytes:10396843122 &lt;span class="o"&gt;(&lt;/span&gt;10.3 GB&lt;span class="o"&gt;)&lt;/span&gt;
        Interrupt:20 Memory:f7c00000-f7c20000

lo        Link encap:Local Loopback
        inet addr:127.0.0.1  Mask:255.0.0.0
        inet6 addr: ::1/128 Scope:Host
        UP LOOPBACK RUNNING  MTU:65536  Metric:1
        RX packets:5095811 errors:0 dropped:0 overruns:0 frame:0
        TX packets:5095811 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:0
        RX bytes:2717552755 &lt;span class="o"&gt;(&lt;/span&gt;2.7 GB&lt;span class="o"&gt;)&lt;/span&gt;  TX bytes:2717552755 &lt;span class="o"&gt;(&lt;/span&gt;2.7 GB&lt;span class="o"&gt;)&lt;/span&gt;

vboxnet0  Link encap:Ethernet  HWaddr 0a:00:27:00:00:00
        inet addr:192.168.56.1  Bcast:192.168.56.255  Mask:255.255.255.0
        inet6 addr: fe80::800:27ff:fe00:0/64 Scope:Link
        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
        RX packets:0 errors:0 dropped:0 overruns:0 frame:0
        TX packets:1505 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:1000
        RX bytes:0 &lt;span class="o"&gt;(&lt;/span&gt;0.0 B&lt;span class="o"&gt;)&lt;/span&gt;  TX bytes:130893 &lt;span class="o"&gt;(&lt;/span&gt;130.8 KB&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="command"></category><category term="netstat"></category></entry><entry><title>ps</title><link href="http://blog.wiseturtles.com/posts/linux-ps.html" rel="alternate"></link><published>2015-01-13T09:51:00+08:00</published><updated>2015-01-13T09:51:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-13:/posts/linux-ps.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;ps&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.binarytides.com/linux-ps-command/"&gt;10 basic examples of Linux ps&amp;nbsp;command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://man.linuxde.net/ps"&gt;http://man.linuxde.net/ps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用&lt;/h2&gt;
&lt;p&gt;ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，可以使用top命令&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;参数形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Unix风格的参数，前面加单破折线&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;BSD&lt;/span&gt;风格的参数，&amp;nbsp;前面不加破折线&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;GNU&lt;/span&gt;风格的长参数，前面加双破折线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同风格的参数可以混合使用,&amp;nbsp;但是要注意避免冲突。&lt;/p&gt;
&lt;p&gt;如:&lt;/p&gt;
&lt;p&gt;命令&lt;code&gt;ps -aux&lt;/code&gt;和&lt;code&gt;ps aux&lt;/code&gt;是不一样的。&lt;code&gt;ps -aux&lt;/code&gt;是显示所有&amp;#8217;x&amp;#8217;用户的进程, 如果用户&amp;#8217;x&amp;#8217;不存在的话，会给出警告，并当做&lt;code&gt;ps aux&lt;/code&gt;来处理。&lt;/p&gt;
&lt;h2&gt;使用示例&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显示所有进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps aux
$ ps -ef
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示指定用户的进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -f -u www-data

&lt;span class="c1"&gt;# 多个用户用&amp;#39;,&amp;#39;隔开&lt;/span&gt;
$ ps -f -u www-data,root
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照进程名来指定&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -C nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-C&amp;nbsp;选项必须提供精确的进程名，不提供模糊匹配，一般使用grep来搜索&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -ef &lt;span class="p"&gt;|&lt;/span&gt;grep nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照进程id来查找&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -f -p 3150,7298,6455
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照&lt;span class="caps"&gt;CPU&lt;/span&gt;或内存使用情况排序&lt;/p&gt;
&lt;p&gt;使用&amp;#8212;sort选项可以按照一定的顺序排序，并且可以在指定的排序列前添加&amp;#8217;-&amp;#8216;或&amp;#8217;+&amp;#8217;&amp;nbsp;来指定降序或升序排列&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# cpu 使用前５&lt;/span&gt;
$ ps aux --sort&lt;span class="o"&gt;=&lt;/span&gt;-pcpu &lt;span class="p"&gt;|&lt;/span&gt; head -5

&lt;span class="c1"&gt;# 内存 使用前５&lt;/span&gt;
$ ps aux --sort&lt;span class="o"&gt;=&lt;/span&gt;-pmem &lt;span class="p"&gt;|&lt;/span&gt; head -5

&lt;span class="c1"&gt;# 指定多个排序&lt;/span&gt;
$ ps jax --sort&lt;span class="o"&gt;=&lt;/span&gt;uid,-ppid,+pid
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排序选项参见man page &lt;code&gt;STANDARD FORMAT SPECIFIERS&lt;/code&gt;部分&lt;/p&gt;
&lt;p&gt;部分选项列出如下
&lt;pre&gt;
cmd          simple name of executable
pcpu         cpu utilization
pmem         ratio of the process's resident set size to the
            physical memory on the machine, expressed as a
            percentage
flags        flags as in long format F field
pgrp         process group ID
tpgid        controlling tty process group ID
cutime       cumulative user time
cstime       cumulative system time
utime        user time
min_flt      number of minor page faults
maj_flt      number of major page faults
cmin_flt     cumulative minor page faults
cmaj_flt     cumulative major page faults
session      session ID
pid          process ID
ppid         parent process ID
rss          resident set size
resident     resident pages
size         approximate amount of swap space that would be
            required if the process were to dirty all writable
            pages and then be swapped out. This number is
            very rough!
share        amount of shared pages
tty          the device number of the controlling tty
start_time   time process was started
uid          user ID number
user         user name
vsize        total VM size in kB
priority     kernel scheduling priority
&lt;/pre&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照树状结构显示&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;--forest&lt;/code&gt;选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -f --forest -C nginx
UID        PID  PPID  C STIME TTY          TIME CMD
root      &lt;span class="m"&gt;1344&lt;/span&gt;     &lt;span class="m"&gt;1&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:00:00 nginx: master process /usr/sbin/nginx
www-data  &lt;span class="m"&gt;1345&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:01:52  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1346&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:02:05  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1348&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:02:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1349&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:01:04  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要把&lt;code&gt;--forest&lt;/code&gt;和&lt;code&gt;--sort&lt;/code&gt;选项混合使用，因为他们都会影响结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出子进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;＃先列出所有nginx进程
$ ps -o pid,uname,comm -C nginx
PID USER     COMMAND
&lt;span class="m"&gt;1344&lt;/span&gt; root     nginx
&lt;span class="m"&gt;1345&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1346&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1348&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1349&lt;/span&gt; www-data nginx

&lt;span class="c1"&gt;# 使用--ppid选项列出子进程&lt;/span&gt;
$ ps --ppid 2359
PID TTY          TIME CMD
&lt;span class="m"&gt;4524&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4525&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4526&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4527&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4528&lt;/span&gt; ?        00:00:00 apache2
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出进程的线程&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-L&lt;/code&gt;选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -p &lt;span class="m"&gt;3150&lt;/span&gt; -L
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定输出结果的列&lt;/p&gt;
&lt;p&gt;可以输出的列信息与&lt;code&gt;--sort&lt;/code&gt;选项一样，可以查看man page 的&lt;code&gt;STANDARD FORMAT SPECIFIERS&lt;/code&gt;部分&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -e -o pid,uname,pcpu,pmem,comm

&lt;span class="c1"&gt;# 显示指定的列并给出别名&lt;/span&gt;
$ ps -e -o pid,uname&lt;span class="o"&gt;=&lt;/span&gt;USERNAME,pcpu&lt;span class="o"&gt;=&lt;/span&gt;CPU_USAGE,pmem,comm
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将ps转变为实时更新的效果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$  watch -n &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出僵尸进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ps -A -o stat,ppid,pid,cmd &lt;span class="p"&gt;|&lt;/span&gt;grep -e &lt;span class="s1"&gt;&amp;#39;^[Zz]&amp;#39;&lt;/span&gt;
$ ps -ef &lt;span class="p"&gt;|&lt;/span&gt; grep defunct &lt;span class="p"&gt;|&lt;/span&gt; grep -v grep
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定用户, 程序的&lt;span class="caps"&gt;CPU&lt;/span&gt;和内存使用情况统计&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# redis用户所使用的cpu和内存信息统计&lt;/span&gt;
$ ps --no-headers -u redis -o pcpu,pmem,command &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{cpu += $1; pmem += $2} END {print cpu, pmem}&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;# 查看只是监听在6000端口的redis使用cpu和内存信息&lt;/span&gt;
$ ps --no-headers -u redis -o pcpu,pmem,command &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="m"&gt;6000&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{cpu += $1; pmem += $2} END {print cpu, pmem}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部分选项解释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
-a： 显示所有终端机下执行的程序，除了阶段作业领导者之外。
a：  显示现行终端机下的所有程序，包括其他用户的程序。
-A： 显示所有程序。
-c： 显示CLS和PRI栏位。
c：  列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
-C&lt;指令名称&gt;： 指定执行指令的名称，并列出该指令的程序的状况。
-d： 显示所有程序，但不包括阶段作业领导者的程序。
-e： 此选项的效果和指定"A"选项相同。
e：  列出程序时，显示每个程序所使用的环境变量。
-f： 显示UID,PPIP,C与STIME栏位。
f：  用ASCII字符显示树状结构，表达程序间的相互关系。
-g&lt;群组名称&gt;： 此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
g：  显示现行终端机下的所有程序，包括群组领导者的程序。 -G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。
h：  不显示标题列。
-H： 显示树状结构，表示程序间的相互关系。
-j或j： 采用工作控制的格式显示程序状况。
-l或l： 采用详细的格式来显示程序状况。
L：  列出栏位的相关信息。
-m或m： 显示所有的执行绪。
n：  以数字来表示USER和WCHAN栏位。
-N： 显示所有的程序，除了执行ps指令终端机下的程序之外。
-p&lt;程序识别码&gt;： 指定程序识别码，并列出该程序的状况。
p&lt;程序识别码&gt;：  此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
r：  只列出现行终端机正在执行中的程序。
-s&lt;阶段作业&gt;：   指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
s：  采用程序信号的格式显示程序状况。
S：  列出程序时，包括已中断的子程序资料。
-t&lt;终端机编号&gt;：  指定终端机编号，并列出属于该终端机的程序的状况。
t&lt;终端机编号&gt;：   此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
-T：   显示现行终端机下的所有程序。
-u&lt;用户识别码&gt;：  此选项的效果和指定"-U"选项相同。
u：  以用户为主的格式来显示程序状况。
-U&lt;用户识别码&gt;：  列出属于该用户的程序的状况，也可使用用户名称来指定。
U&lt;用户名称&gt;：  列出属于该用户的程序的状况。
v：  采用虚拟内存的格式显示程序状况。
-V或V：  显示版本信息。
-w或w：  采用宽阔的格式来显示程序状况。　
x：  显示所有程序，不以终端机来区分。
X：  采用旧式的Linux i386登陆格式显示程序状况。
-y：  配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
-&lt;程序识别码&gt;：  此选项的效果和指定"p"选项相同。
--cols&lt;每列字符数&gt;：  设置每列的最大字符数。
--columns&lt;每列字符数&gt;：  此选项的效果和指定"--cols"选项相同。
--cumulative：  此选项的效果和指定"S"选项相同。
--deselect：  此选项的效果和指定"-N"选项相同。
--forest：  此选项的效果和指定"f"选项相同。
--headers：  重复显示标题列。
--help：  在线帮助。
--info：  显示排错信息。
--lines&lt;显示列数&gt;：  设置显示画面的列数。
--no-headers：  此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
--group&lt;群组名称&gt;：  此选项的效果和指定"-G"选项相同。
--Group&lt;群组识别码&gt;：  此选项的效果和指定"-G"选项相同。
--pid&lt;程序识别码&gt;：  此选项的效果和指定"-p"选项相同。
--rows&lt;显示列数&gt;：  此选项的效果和指定"--lines"选项相同。
--sid&lt;阶段作业&gt;：  此选项的效果和指定"-s"选项相同。
--tty&lt;终端机编号&gt;：  此选项的效果和指定"-t"选项相同。
--user&lt;用户名称&gt;：  此选项的效果和指定"-U"选项相同。
--User&lt;用户识别码&gt;：  此选项的效果和指定"-U"选项相同。
--version：  此选项的效果和指定"-V"选项相同。
--widty&lt;每列字符数&gt;：  此选项的效果和指定"-cols"选项相同。
&lt;/pre&gt;</content><category term="linux"></category><category term="command"></category><category term="ps"></category></entry><entry><title>free</title><link href="http://blog.wiseturtles.com/posts/linux-free.html" rel="alternate"></link><published>2015-01-09T15:27:00+08:00</published><updated>2015-01-09T15:27:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-09:/posts/linux-free.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;free&lt;/p&gt;</summary><content type="html">&lt;p&gt;本来转载自:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html"&gt;http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多free命令可参看:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/chap-Oracle_9i_and_10g_Tuning_Guide-Memory_Usage_and_Page_Cache.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.linuxatemyram.com/"&gt;http://www.linuxatemyram.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;top命令输出解释&lt;/h2&gt;
&lt;p&gt;下面是free的运行结果，一共有4行。为了方便说明，我加上了列号.
&lt;pre&gt;
                   1          2          3          4          5          6
1              total       used       free     shared    buffers     cached
2 Mem:      24677460   23276064    1401396          0     870540   12084008
3 -/+ buffers/cache:   10321516   14355944
4 Swap:     25151484     224188   24927296
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;这样可以把free的输出看成一个二维数组&lt;span class="caps"&gt;FO&lt;/span&gt;(Free&amp;nbsp;Output)。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FO[2][1] = 24677460
FO[3][2] = 10321516
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。
free输出的第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。
第一行的输出时从操作系统（&lt;span class="caps"&gt;OS&lt;/span&gt;）来看的。也就是说，从&lt;span class="caps"&gt;OS&lt;/span&gt;的角度来看，计算机上一共有:
&lt;span class="caps"&gt;24677460KB&lt;/span&gt;（缺省时free的单位为&lt;span class="caps"&gt;KB&lt;/span&gt;）物理内存，即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][1]；在这些物理内存中有&lt;span class="caps"&gt;23276064KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][2]）被使用了；还用&lt;span class="caps"&gt;1401396KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]）是可用的；&amp;nbsp;这里得到第一个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FO[2][1] = FO[2][2] + FO[2][3]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][5]表示被&lt;span class="caps"&gt;OS&lt;/span&gt; buffer住的内存。&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]表示被&lt;span class="caps"&gt;OS&lt;/span&gt;&amp;nbsp;cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is something that has yet to be &amp;#8220;written&amp;#8221; to&amp;nbsp;disk.&lt;/li&gt;
&lt;li&gt;A cache is something that has been &amp;#8220;read&amp;#8221; from the disk and stored for later&amp;nbsp;use.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高&lt;span class="caps"&gt;IO&lt;/span&gt;性能的，并由&lt;span class="caps"&gt;OS&lt;/span&gt;管理。&lt;/p&gt;
&lt;p&gt;Linux和其他成熟的操作系统（例如windows），为了提高&lt;span class="caps"&gt;IO&lt;/span&gt; read的性能，总是要多cache一些数据，这也就是为什么&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]（cached memory）比较大，而&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]比较小的原因。我们可以做一个简单的测试:&lt;/p&gt;
&lt;p&gt;释放掉被系统cache占用的数据；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;echo 3&amp;gt;/proc/sys/vm/drop_caches
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读一个大文件，并记录时间；
关闭该文件；
重读这个大文件，并记录时间；&amp;nbsp;第二次读应该比第一次快很多。原来我做过一个BerkeleyDB的读操作，大概要读5G的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快9倍左右。&lt;/p&gt;
&lt;p&gt;free输出的第二行是从一个应用程序的角度看系统内存的使用情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；&lt;/li&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为被系统cache和buffer占用的内存可以被快速回收，所以通常&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]比&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]会大很多。&lt;/p&gt;
&lt;p&gt;这里还用两个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这二者都不难理解。&lt;/p&gt;
&lt;p&gt;free命令由procps.*.rpm提供（在Redhat系列的&lt;span class="caps"&gt;OS&lt;/span&gt;上）。free命令的所有输出值都是从/proc/meminfo中读出的。&lt;/p&gt;
&lt;p&gt;在系统上可能有meminfo(2)这个函数，它就是为了解析/proc/meminfo的。procps这个包自己实现了meminfo()这个函数。可以下载一个procps的tar包看看具体实现，现在最新版式3.2.8。&lt;/p&gt;</content><category term="linux"></category><category term="command"></category><category term="free"></category></entry><entry><title>htop</title><link href="http://blog.wiseturtles.com/posts/linux-htop.html" rel="alternate"></link><published>2015-01-09T14:04:00+08:00</published><updated>2015-01-09T14:04:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-09:/posts/linux-htop.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;htop&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文转摘自 &lt;a href="https://blog.linuxeye.com/350.html"&gt;Linux运维笔记&lt;/a&gt;.&amp;nbsp;并做适当修改　&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Htop是一款运行于Linux系统监控与进程管理软件，用于取代Unix下传统的top。与top只提供最消耗资源的进程列表不同，htop提供所有进程的列表，并且使用彩色标识出处理器、swap和内存状态。&lt;/p&gt;
&lt;p&gt;用户一般可以在top无法提供详尽系统信息的情况下选择安装并使用htop。比如，在查找应用程序的内存泄漏问题时。与top相比，htop提供更方便、光标控制的界面来杀死进程。&lt;/p&gt;
&lt;p&gt;htop用C语言编写，采用了ncurses库。htop的名称源于其作者的名字。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;htop安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get install htop
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;htop用法&lt;/p&gt;
&lt;p&gt;&lt;img alt="htop screenshot" src="http://pic.yupoo.com/crazygit_v/ElYP0hQ6/medium.jpg"&gt;&lt;/p&gt;
&lt;p&gt;上面左上角显示&lt;span class="caps"&gt;CPU&lt;/span&gt;、内存、Swap使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用快捷键&lt;/p&gt;
&lt;p&gt;下面是 F1~F10 的功能和对应的字母快捷键。
&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    Shortcut Key
&lt;/td&gt;
&lt;td&gt;
    Function Key
&lt;/td&gt;
&lt;td&gt;
    Description
&lt;/td&gt;
&lt;td&gt;
    中文说明
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    h, ?
&lt;/td&gt;
&lt;td&gt;
    F1
&lt;/td&gt;
&lt;td&gt;
    Invoke htop Help
&lt;/td&gt;
&lt;td&gt;
    查看htop使用说明
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    S
&lt;/td&gt;
&lt;td&gt;
    F2
&lt;/td&gt;
&lt;td&gt;
    Htop Setup Menu
&lt;/td&gt;
&lt;td&gt;
    htop 设定
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    /
&lt;/td&gt;
&lt;td&gt;
    F3
&lt;/td&gt;
&lt;td&gt;
    Search for a Process
&lt;/td&gt;
&lt;td&gt;
    搜索进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    \
&lt;/td&gt;
&lt;td&gt;
    F4
&lt;/td&gt;
&lt;td&gt;
    Incremental process filtering
&lt;/td&gt;
&lt;td&gt;
    增量进程过滤器
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    t
&lt;/td&gt;
&lt;td&gt;
    F5
&lt;/td&gt;
&lt;td&gt;
    Tree View
&lt;/td&gt;
&lt;td&gt;
    显示树形结构
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    ,
&lt;/td&gt;
&lt;td&gt;
    F6
&lt;/td&gt;
&lt;td&gt;
    Sort by a column
&lt;/td&gt;
&lt;td&gt;
    选择排序方式
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    [
&lt;/td&gt;
&lt;td&gt;
    F7
&lt;/td&gt;
&lt;td&gt;
    Nice – (change priority)
&lt;/td&gt;
&lt;td&gt;
    可减少nice值，这样就可以提高对应进程的优先级
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    ]
&lt;/td&gt;
&lt;td&gt;
    F8
&lt;/td&gt;
&lt;td&gt;
    Nice + (change priority)
&lt;/td&gt;
&lt;td&gt;
    可增加nice值，这样就可以降低对应进程的优先级
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    k
&lt;/td&gt;
&lt;td&gt;
    F9
&lt;/td&gt;
&lt;td&gt;
    Kill a Process
&lt;/td&gt;
&lt;td&gt;
    可对进程传递信号
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    q
&lt;/td&gt;
&lt;td&gt;
    F10
&lt;/td&gt;
&lt;td&gt;
    Quit htop
&lt;/td&gt;
&lt;td&gt;
    结束htop
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行选项（&lt;span class="caps"&gt;COMMAND&lt;/span&gt;-&lt;span class="caps"&gt;LINE&lt;/span&gt; &lt;span class="caps"&gt;OPTIONS&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    -C –no-color
&lt;/td&gt;
&lt;td&gt;
    使用一个单色的配色方案
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -d –delay=&lt;span class="caps"&gt;DELAY&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    设置延迟更新时间，单位秒
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -h –help
&lt;/td&gt;
&lt;td&gt;
    显示htop 命令帮助信息
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -u –user=&lt;span class="caps"&gt;USERNAME&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    只显示一个给定的用户的过程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -p –pid=&lt;span class="caps"&gt;PID&lt;/span&gt;,&lt;span class="caps"&gt;PID&lt;/span&gt;…
&lt;/td&gt;
&lt;td&gt;
    只显示给定的PIDs
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -s –sort-key &lt;span class="caps"&gt;COLUMN&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    依此列来排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -v –version
&lt;/td&gt;
&lt;td&gt;
    显示版本信息
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交互式命令（&lt;span class="caps"&gt;INTERACTIVE&lt;/span&gt; &lt;span class="caps"&gt;COMMANDS&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    上下键或PgUP, PgDn
&lt;/td&gt;
&lt;td&gt;
    选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Space
&lt;/td&gt;
&lt;td&gt;
    标记/取消标记一个进程。命令可以作用于多个进程，例如 “kill”，将应用于所有已标记的进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    U
&lt;/td&gt;
&lt;td&gt;
    取消标记所有进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    s
&lt;/td&gt;
&lt;td&gt;
    选择某一进程，按s:用strace追踪进程的系统调用
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    l
&lt;/td&gt;
&lt;td&gt;
    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    I
&lt;/td&gt;
&lt;td&gt;
    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    +, -
&lt;/td&gt;
&lt;td&gt;
    在树形模式下，展开或折叠子树
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    a (在有多处理器的机器上)
&lt;/td&gt;
&lt;td&gt;
    设置 &lt;span class="caps"&gt;CPU&lt;/span&gt; affinity: 标记一个进程允许使用哪些&lt;span class="caps"&gt;CPU&lt;/span&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    u
&lt;/td&gt;
&lt;td&gt;
    显示特定用户进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    M
&lt;/td&gt;
&lt;td&gt;
    按Memory使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    P
&lt;/td&gt;
&lt;td&gt;
    按&lt;span class="caps"&gt;CPU&lt;/span&gt;使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    T
&lt;/td&gt;
&lt;td&gt;
    按Time+使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    F
&lt;/td&gt;
&lt;td&gt;
    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    K
&lt;/td&gt;
&lt;td&gt;
    显示/隐藏内核线程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    H
&lt;/td&gt;
&lt;td&gt;
    显示/隐藏用户线程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Ctrl-L
&lt;/td&gt;
&lt;td&gt;
    刷新
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Numbers
&lt;/td&gt;
&lt;td&gt;
    &lt;span class="caps"&gt;PID&lt;/span&gt; 查找: 输入&lt;span class="caps"&gt;PID&lt;/span&gt;，光标将移动到相应的进程上
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替代top&lt;/p&gt;
&lt;p&gt;用htop替换top，可添加别名，编辑&lt;code&gt;~/.bashrc&lt;/code&gt;文件，添加如下代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias top=htop
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;</content><category term="linux"></category><category term="command"></category><category term="htop"></category></entry><entry><title>uptime</title><link href="http://blog.wiseturtles.com/posts/linux-uptime.html" rel="alternate"></link><published>2014-12-15T10:08:00+08:00</published><updated>2014-12-15T10:08:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2014-12-15:/posts/linux-uptime.html</id><summary type="html">&lt;p&gt;the usage of&amp;nbsp;uptime&lt;/p&gt;</summary><content type="html">&lt;h2&gt;用途&lt;/h2&gt;
&lt;p&gt;man&amp;nbsp;page&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;uptime gives a one line display of the following information.  The cur‐
rent time, how long the system has been running,  how  many  users  are
currently  logged  on,  and the system load averages for the past 1, 5,
and 15&amp;nbsp;minutes.&lt;/p&gt;
&lt;p&gt;System load averages is the average number of processes that are either
in a runnable or uninterruptable state.  A process in a runnable  state
is  either  using the &lt;span class="caps"&gt;CPU&lt;/span&gt; or waiting to use the &lt;span class="caps"&gt;CPU&lt;/span&gt;. A process in unin‐
terruptable state is waiting for some I/O access, eg waiting for  disk.
The  averages  are  taken over the three time intervals. Load averages
are not normalized for the number of CPUs in a system, so a load  aver‐
age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4
&lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Load averages are not normalized for the number of CPUs in a system, so a load  aver‐ age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4 &lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ uptime
10:14:31 up &lt;span class="m"&gt;10&lt;/span&gt; days, 20:55,  &lt;span class="m"&gt;6&lt;/span&gt; users,  load average: 0.28, 0.42, 0.54
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的结果显示的分别是系统的当前时间，运行时间，当前用户数，过去1, 5, 15分钟的系统平均负载
总体来说，值为1时，当只有单个&lt;span class="caps"&gt;CPU&lt;/span&gt;表示已经完全利用，当有４个&lt;span class="caps"&gt;CPU&lt;/span&gt;时，表示还有75%的空闲.&lt;/p&gt;
&lt;p&gt;关于平均负载的值可以阅读&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages"&gt;http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages&lt;/a&gt;&lt;/p&gt;</content><category term="linux"></category><category term="command"></category><category term="uptime"></category></entry></feed>