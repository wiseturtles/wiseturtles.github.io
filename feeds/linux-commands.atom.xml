<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wise Turtles</title><link href="http://blog.wiseturtles.com/" rel="alternate"></link><link href="http://blog.wiseturtles.com/feeds/linux-commands.atom.xml" rel="self"></link><id>http://blog.wiseturtles.com/</id><updated>2015-01-09T15:27:00+08:00</updated><entry><title>free</title><link href="http://blog.wiseturtles.com/posts/linux-free.html" rel="alternate"></link><updated>2015-01-09T15:27:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-09:posts/linux-free.html</id><summary type="html">&lt;p&gt;本来转载自:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html"&gt;http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多free命令可参看:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/chap-Oracle_9i_and_10g_Tuning_Guide-Memory_Usage_and_Page_Cache.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.linuxatemyram.com/"&gt;http://www.linuxatemyram.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;top命令输出解释&lt;/h2&gt;
&lt;p&gt;下面是free的运行结果，一共有4行。为了方便说明，我加上了列号.
&lt;pre&gt;
                   1          2          3          4          5          6
1              total       used       free     shared    buffers     cached
2 Mem:      24677460   23276064    1401396          0     870540   12084008
3 -/+ buffers/cache:   10321516   14355944
4 Swap:     25151484     224188   24927296
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;这样可以把free的输出看成一个二维数组&lt;span class="caps"&gt;FO&lt;/span&gt;(Free&amp;nbsp;Output)。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[2][1] = 24677460
FO[3][2] = 10321516
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。
free输出的第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。
第一行的输出时从操作系统（&lt;span class="caps"&gt;OS&lt;/span&gt;）来看的。也就是说，从&lt;span class="caps"&gt;OS&lt;/span&gt;的角度来看，计算机上一共有:
&lt;span class="caps"&gt;24677460KB&lt;/span&gt;（缺省时free的单位为&lt;span class="caps"&gt;KB&lt;/span&gt;）物理内存，即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][1]；在这些物理内存中有&lt;span class="caps"&gt;23276064KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][2]）被使用了；还用&lt;span class="caps"&gt;1401396KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]）是可用的；&amp;nbsp;这里得到第一个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[2][1] = FO[2][2] + FO[2][3]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][5]表示被&lt;span class="caps"&gt;OS&lt;/span&gt; buffer住的内存。&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]表示被&lt;span class="caps"&gt;OS&lt;/span&gt;&amp;nbsp;cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is something that has yet to be &amp;#8220;written&amp;#8221; to&amp;nbsp;disk.&lt;/li&gt;
&lt;li&gt;A cache is something that has been &amp;#8220;read&amp;#8221; from the disk and stored for later&amp;nbsp;use.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高&lt;span class="caps"&gt;IO&lt;/span&gt;性能的，并由&lt;span class="caps"&gt;OS&lt;/span&gt;管理。&lt;/p&gt;
&lt;p&gt;Linux和其他成熟的操作系统（例如windows），为了提高&lt;span class="caps"&gt;IO&lt;/span&gt; read的性能，总是要多cache一些数据，这也就是为什么&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]（cached memory）比较大，而&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]比较小的原因。我们可以做一个简单的测试:&lt;/p&gt;
&lt;p&gt;释放掉被系统cache占用的数据；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;echo 3&amp;gt;/proc/sys/vm/drop_caches
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读一个大文件，并记录时间；
关闭该文件；
重读这个大文件，并记录时间；&amp;nbsp;第二次读应该比第一次快很多。原来我做过一个BerkeleyDB的读操作，大概要读5G的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快9倍左右。&lt;/p&gt;
&lt;p&gt;free输出的第二行是从一个应用程序的角度看系统内存的使用情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；&lt;/li&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为被系统cache和buffer占用的内存可以被快速回收，所以通常&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]比&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]会大很多。&lt;/p&gt;
&lt;p&gt;这里还用两个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这二者都不难理解。&lt;/p&gt;
&lt;p&gt;free命令由procps.*.rpm提供（在Redhat系列的&lt;span class="caps"&gt;OS&lt;/span&gt;上）。free命令的所有输出值都是从/proc/meminfo中读出的。&lt;/p&gt;
&lt;p&gt;在系统上可能有meminfo(2)这个函数，它就是为了解析/proc/meminfo的。procps这个包自己实现了meminfo()这个函数。可以下载一个procps的tar包看看具体实现，现在最新版式3.2.8。&lt;/p&gt;</summary><category term="linux"></category><category term="command"></category><category term="free"></category></entry><entry><title>uptime</title><link href="http://blog.wiseturtles.com/posts/linux-uptime.html" rel="alternate"></link><updated>2014-12-15T10:08:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2014-12-15:posts/linux-uptime.html</id><summary type="html">&lt;h2&gt;用途&lt;/h2&gt;
&lt;p&gt;man&amp;nbsp;page&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;uptime gives a one line display of the following information.  The cur‐
rent time, how long the system has been running,  how  many  users  are
currently  logged  on,  and the system load averages for the past 1, 5,
and 15&amp;nbsp;minutes.&lt;/p&gt;
&lt;p&gt;System load averages is the average number of processes that are either
in a runnable or uninterruptable state.  A process in a runnable  state
is  either  using the &lt;span class="caps"&gt;CPU&lt;/span&gt; or waiting to use the &lt;span class="caps"&gt;CPU&lt;/span&gt;. A process in unin‐
terruptable state is waiting for some I/O access, eg waiting for  disk.
The  averages  are  taken over the three time intervals. Load averages
are not normalized for the number of CPUs in a system, so a load  aver‐
age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4
&lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Load averages are not normalized for the number of CPUs in a system, so a load  aver‐ age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4 &lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;uptime
10:14:31 up &lt;span class="m"&gt;10&lt;/span&gt; days, 20:55,  &lt;span class="m"&gt;6&lt;/span&gt; users,  load average: 0.28, 0.42, 0.54
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的结果显示的分别是系统的当前时间，运行时间，当前用户数，过去1, 5, 15分钟的系统平均负载
总体来说，值为1时，当只有单个&lt;span class="caps"&gt;CPU&lt;/span&gt;表示已经完全利用，当有４个&lt;span class="caps"&gt;CPU&lt;/span&gt;时，表示还有75%的空闲.&lt;/p&gt;
&lt;p&gt;关于平均负载的值可以阅读&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages"&gt;http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="command"></category><category term="uptime"></category></entry></feed>