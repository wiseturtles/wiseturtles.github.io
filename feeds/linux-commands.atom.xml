<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wise Turtles</title><link href="http://blog.wiseturtles.com/" rel="alternate"></link><link href="http://blog.wiseturtles.com/feeds/linux-commands.atom.xml" rel="self"></link><id>http://blog.wiseturtles.com/</id><updated>2015-01-13T09:51:00+08:00</updated><entry><title>ps</title><link href="http://blog.wiseturtles.com/posts/linux-ps.html" rel="alternate"></link><updated>2015-01-13T09:51:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-13:posts/linux-ps.html</id><summary type="html">&lt;p&gt;本文参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.binarytides.com/linux-ps-command/"&gt;10 basic examples of Linux ps&amp;nbsp;command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://man.linuxde.net/ps"&gt;http://man.linuxde.net/ps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用&lt;/h2&gt;
&lt;p&gt;ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，可以使用top命令&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;参数形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Unix风格的参数，前面加单破折线&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;BSD&lt;/span&gt;风格的参数，&amp;nbsp;前面不加破折线&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;GNU&lt;/span&gt;风格的长参数，前面加双破折线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同风格的参数可以混合使用,&amp;nbsp;但是要注意避免冲突。&lt;/p&gt;
&lt;p&gt;如:&lt;/p&gt;
&lt;p&gt;命令&lt;code&gt;ps -aux&lt;/code&gt;和&lt;code&gt;ps aux&lt;/code&gt;是不一样的。&lt;code&gt;ps -aux&lt;/code&gt;是显示所有&amp;#8217;x&amp;#8217;用户的进程, 如果用户&amp;#8217;x&amp;#8217;不存在的话，会给出警告，并当做&lt;code&gt;ps aux&lt;/code&gt;来处理。&lt;/p&gt;
&lt;h2&gt;使用示例&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显示所有进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps aux
&lt;span class="nv"&gt;$ &lt;/span&gt;ps -ef
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示指定用户的进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -f -u www-data

&lt;span class="c"&gt;# 多个用户用&amp;#39;,&amp;#39;隔开&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps -f -u www-data,root
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照进程名来指定&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -C nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-C&amp;nbsp;选项必须提供精确的进程名，不提供模糊匹配，一般使用grep来搜索&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -ef &lt;span class="p"&gt;|&lt;/span&gt;grep nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照进程id来查找&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -f -p 3150,7298,6455
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照&lt;span class="caps"&gt;CPU&lt;/span&gt;或内存使用情况排序&lt;/p&gt;
&lt;p&gt;使用&amp;#8212;sort选项可以按照一定的顺序排序，并且可以在指定的排序列前添加&amp;#8217;-&amp;#8216;或&amp;#8217;+&amp;#8217;&amp;nbsp;来指定降序或升序排列&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# cpu 使用前５&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps aux --sort&lt;span class="o"&gt;=&lt;/span&gt;-pcpu &lt;span class="p"&gt;|&lt;/span&gt; head -5

&lt;span class="c"&gt;# 内存 使用前５&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps aux --sort&lt;span class="o"&gt;=&lt;/span&gt;-pmem &lt;span class="p"&gt;|&lt;/span&gt; head -5

&lt;span class="c"&gt;# 指定多个排序&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps jax --sort&lt;span class="o"&gt;=&lt;/span&gt;uid,-ppid,+pid
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排序选项参见man page &lt;code&gt;STANDARD FORMAT SPECIFIERS&lt;/code&gt;部分&lt;/p&gt;
&lt;p&gt;部分选项列出如下
&lt;pre&gt;
cmd          simple name of executable
pcpu         cpu utilization
pmem         ratio of the process's resident set size to the
            physical memory on the machine, expressed as a
            percentage
flags        flags as in long format F field
pgrp         process group ID
tpgid        controlling tty process group ID
cutime       cumulative user time
cstime       cumulative system time
utime        user time
min_flt      number of minor page faults
maj_flt      number of major page faults
cmin_flt     cumulative minor page faults
cmaj_flt     cumulative major page faults
session      session ID
pid          process ID
ppid         parent process ID
rss          resident set size
resident     resident pages
size         approximate amount of swap space that would be
            required if the process were to dirty all writable
            pages and then be swapped out. This number is
            very rough!
share        amount of shared pages
tty          the device number of the controlling tty
start_time   time process was started
uid          user ID number
user         user name
vsize        total VM size in kB
priority     kernel scheduling priority
&lt;/pre&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照树状结构显示&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;--forest&lt;/code&gt;选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -f --forest -C nginx
UID        PID  PPID  C STIME TTY          TIME CMD
root      &lt;span class="m"&gt;1344&lt;/span&gt;     &lt;span class="m"&gt;1&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:00:00 nginx: master process /usr/sbin/nginx
www-data  &lt;span class="m"&gt;1345&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:01:52  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1346&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:02:05  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1348&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:02:00  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
www-data  &lt;span class="m"&gt;1349&lt;/span&gt;  &lt;span class="m"&gt;1344&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;  &lt;span class="m"&gt;2014&lt;/span&gt; ?        00:01:04  &lt;span class="se"&gt;\_&lt;/span&gt; nginx: worker process
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要把&lt;code&gt;--forest&lt;/code&gt;和&lt;code&gt;--sort&lt;/code&gt;选项混合使用，因为他们都会影响结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出子进程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;＃先列出所有nginx进程
&lt;span class="nv"&gt;$ &lt;/span&gt;ps -o pid,uname,comm -C nginx
PID USER     COMMAND
&lt;span class="m"&gt;1344&lt;/span&gt; root     nginx
&lt;span class="m"&gt;1345&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1346&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1348&lt;/span&gt; www-data nginx
&lt;span class="m"&gt;1349&lt;/span&gt; www-data nginx

&lt;span class="c"&gt;# 使用--ppid选项列出子进程&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps --ppid 2359
PID TTY          TIME CMD
&lt;span class="m"&gt;4524&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4525&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4526&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4527&lt;/span&gt; ?        00:00:00 apache2
&lt;span class="m"&gt;4528&lt;/span&gt; ?        00:00:00 apache2
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出进程的线程&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-L&lt;/code&gt;选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -p &lt;span class="m"&gt;3150&lt;/span&gt; -L
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定输出结果的列&lt;/p&gt;
&lt;p&gt;可以输出的列信息与&lt;code&gt;--sort&lt;/code&gt;选项一样，可以查看man page 的&lt;code&gt;STANDARD FORMAT SPECIFIERS&lt;/code&gt;部分&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ps -e -o pid,uname,pcpu,pmem,comm

&lt;span class="c"&gt;# 显示指定的列并给出别名&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;ps -e -o pid,uname&lt;span class="o"&gt;=&lt;/span&gt;USERNAME,pcpu&lt;span class="o"&gt;=&lt;/span&gt;CPU_USAGE,pmem,comm
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将ps转变为实时更新的效果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt; watch -n &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部分选项解释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
-a： 显示所有终端机下执行的程序，除了阶段作业领导者之外。
a：  显示现行终端机下的所有程序，包括其他用户的程序。
-A： 显示所有程序。
-c： 显示CLS和PRI栏位。
c：  列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
-C&lt;指令名称&gt;： 指定执行指令的名称，并列出该指令的程序的状况。
-d： 显示所有程序，但不包括阶段作业领导者的程序。
-e： 此选项的效果和指定"A"选项相同。
e：  列出程序时，显示每个程序所使用的环境变量。
-f： 显示UID,PPIP,C与STIME栏位。
f：  用ASCII字符显示树状结构，表达程序间的相互关系。
-g&lt;群组名称&gt;： 此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
g：  显示现行终端机下的所有程序，包括群组领导者的程序。 -G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。
h：  不显示标题列。
-H： 显示树状结构，表示程序间的相互关系。
-j或j： 采用工作控制的格式显示程序状况。
-l或l： 采用详细的格式来显示程序状况。
L：  列出栏位的相关信息。
-m或m： 显示所有的执行绪。
n：  以数字来表示USER和WCHAN栏位。
-N： 显示所有的程序，除了执行ps指令终端机下的程序之外。
-p&lt;程序识别码&gt;： 指定程序识别码，并列出该程序的状况。
p&lt;程序识别码&gt;：  此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
r：  只列出现行终端机正在执行中的程序。
-s&lt;阶段作业&gt;：   指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
s：  采用程序信号的格式显示程序状况。
S：  列出程序时，包括已中断的子程序资料。
-t&lt;终端机编号&gt;：  指定终端机编号，并列出属于该终端机的程序的状况。
t&lt;终端机编号&gt;：   此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
-T：   显示现行终端机下的所有程序。
-u&lt;用户识别码&gt;：  此选项的效果和指定"-U"选项相同。
u：  以用户为主的格式来显示程序状况。
-U&lt;用户识别码&gt;：  列出属于该用户的程序的状况，也可使用用户名称来指定。
U&lt;用户名称&gt;：  列出属于该用户的程序的状况。
v：  采用虚拟内存的格式显示程序状况。
-V或V：  显示版本信息。
-w或w：  采用宽阔的格式来显示程序状况。　
x：  显示所有程序，不以终端机来区分。
X：  采用旧式的Linux i386登陆格式显示程序状况。
-y：  配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
-&lt;程序识别码&gt;：  此选项的效果和指定"p"选项相同。
--cols&lt;每列字符数&gt;：  设置每列的最大字符数。
--columns&lt;每列字符数&gt;：  此选项的效果和指定"--cols"选项相同。
--cumulative：  此选项的效果和指定"S"选项相同。
--deselect：  此选项的效果和指定"-N"选项相同。
--forest：  此选项的效果和指定"f"选项相同。
--headers：  重复显示标题列。
--help：  在线帮助。
--info：  显示排错信息。
--lines&lt;显示列数&gt;：  设置显示画面的列数。
--no-headers：  此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
--group&lt;群组名称&gt;：  此选项的效果和指定"-G"选项相同。
--Group&lt;群组识别码&gt;：  此选项的效果和指定"-G"选项相同。
--pid&lt;程序识别码&gt;：  此选项的效果和指定"-p"选项相同。
--rows&lt;显示列数&gt;：  此选项的效果和指定"--lines"选项相同。
--sid&lt;阶段作业&gt;：  此选项的效果和指定"-s"选项相同。
--tty&lt;终端机编号&gt;：  此选项的效果和指定"-t"选项相同。
--user&lt;用户名称&gt;：  此选项的效果和指定"-U"选项相同。
--User&lt;用户识别码&gt;：  此选项的效果和指定"-U"选项相同。
--version：  此选项的效果和指定"-V"选项相同。
--widty&lt;每列字符数&gt;：  此选项的效果和指定"-cols"选项相同。
&lt;/pre&gt;</summary><category term="linux"></category><category term="command"></category><category term="ps"></category></entry><entry><title>free</title><link href="http://blog.wiseturtles.com/posts/linux-free.html" rel="alternate"></link><updated>2015-01-09T15:27:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-09:posts/linux-free.html</id><summary type="html">&lt;p&gt;本来转载自:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html"&gt;http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多free命令可参看:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/chap-Oracle_9i_and_10g_Tuning_Guide-Memory_Usage_and_Page_Cache.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.linuxatemyram.com/"&gt;http://www.linuxatemyram.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;top命令输出解释&lt;/h2&gt;
&lt;p&gt;下面是free的运行结果，一共有4行。为了方便说明，我加上了列号.
&lt;pre&gt;
                   1          2          3          4          5          6
1              total       used       free     shared    buffers     cached
2 Mem:      24677460   23276064    1401396          0     870540   12084008
3 -/+ buffers/cache:   10321516   14355944
4 Swap:     25151484     224188   24927296
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;这样可以把free的输出看成一个二维数组&lt;span class="caps"&gt;FO&lt;/span&gt;(Free&amp;nbsp;Output)。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[2][1] = 24677460
FO[3][2] = 10321516
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。
free输出的第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。
第一行的输出时从操作系统（&lt;span class="caps"&gt;OS&lt;/span&gt;）来看的。也就是说，从&lt;span class="caps"&gt;OS&lt;/span&gt;的角度来看，计算机上一共有:
&lt;span class="caps"&gt;24677460KB&lt;/span&gt;（缺省时free的单位为&lt;span class="caps"&gt;KB&lt;/span&gt;）物理内存，即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][1]；在这些物理内存中有&lt;span class="caps"&gt;23276064KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][2]）被使用了；还用&lt;span class="caps"&gt;1401396KB&lt;/span&gt;（即&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]）是可用的；&amp;nbsp;这里得到第一个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[2][1] = FO[2][2] + FO[2][3]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;FO&lt;/span&gt;[2][5]表示被&lt;span class="caps"&gt;OS&lt;/span&gt; buffer住的内存。&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]表示被&lt;span class="caps"&gt;OS&lt;/span&gt;&amp;nbsp;cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is something that has yet to be &amp;#8220;written&amp;#8221; to&amp;nbsp;disk.&lt;/li&gt;
&lt;li&gt;A cache is something that has been &amp;#8220;read&amp;#8221; from the disk and stored for later&amp;nbsp;use.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高&lt;span class="caps"&gt;IO&lt;/span&gt;性能的，并由&lt;span class="caps"&gt;OS&lt;/span&gt;管理。&lt;/p&gt;
&lt;p&gt;Linux和其他成熟的操作系统（例如windows），为了提高&lt;span class="caps"&gt;IO&lt;/span&gt; read的性能，总是要多cache一些数据，这也就是为什么&lt;span class="caps"&gt;FO&lt;/span&gt;[2][6]（cached memory）比较大，而&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]比较小的原因。我们可以做一个简单的测试:&lt;/p&gt;
&lt;p&gt;释放掉被系统cache占用的数据；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;echo 3&amp;gt;/proc/sys/vm/drop_caches
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读一个大文件，并记录时间；
关闭该文件；
重读这个大文件，并记录时间；&amp;nbsp;第二次读应该比第一次快很多。原来我做过一个BerkeleyDB的读操作，大概要读5G的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快9倍左右。&lt;/p&gt;
&lt;p&gt;free输出的第二行是从一个应用程序的角度看系统内存的使用情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；&lt;/li&gt;
&lt;li&gt;对于&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为被系统cache和buffer占用的内存可以被快速回收，所以通常&lt;span class="caps"&gt;FO&lt;/span&gt;[3][3]比&lt;span class="caps"&gt;FO&lt;/span&gt;[2][3]会大很多。&lt;/p&gt;
&lt;p&gt;这里还用两个等式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这二者都不难理解。&lt;/p&gt;
&lt;p&gt;free命令由procps.*.rpm提供（在Redhat系列的&lt;span class="caps"&gt;OS&lt;/span&gt;上）。free命令的所有输出值都是从/proc/meminfo中读出的。&lt;/p&gt;
&lt;p&gt;在系统上可能有meminfo(2)这个函数，它就是为了解析/proc/meminfo的。procps这个包自己实现了meminfo()这个函数。可以下载一个procps的tar包看看具体实现，现在最新版式3.2.8。&lt;/p&gt;</summary><category term="linux"></category><category term="command"></category><category term="free"></category></entry><entry><title>htop</title><link href="http://blog.wiseturtles.com/posts/linux-htop.html" rel="alternate"></link><updated>2015-01-09T14:04:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2015-01-09:posts/linux-htop.html</id><summary type="html">&lt;p&gt;本文转摘自 &lt;a href="https://blog.linuxeye.com/350.html"&gt;Linux运维笔记&lt;/a&gt;.&amp;nbsp;并做适当修改　&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Htop是一款运行于Linux系统监控与进程管理软件，用于取代Unix下传统的top。与top只提供最消耗资源的进程列表不同，htop提供所有进程的列表，并且使用彩色标识出处理器、swap和内存状态。&lt;/p&gt;
&lt;p&gt;用户一般可以在top无法提供详尽系统信息的情况下选择安装并使用htop。比如，在查找应用程序的内存泄漏问题时。与top相比，htop提供更方便、光标控制的界面来杀死进程。&lt;/p&gt;
&lt;p&gt;htop用C语言编写，采用了ncurses库。htop的名称源于其作者的名字。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;htop安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install htop
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;htop用法&lt;/p&gt;
&lt;p&gt;&lt;img alt="htop screenshot" src="http://pic.yupoo.com/crazygit_v/ElYP0hQ6/medium.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;上面左上角显示&lt;span class="caps"&gt;CPU&lt;/span&gt;、内存、Swap使用情况，右边显示任务、负载、开机时间，下面&amp;nbsp;就是进程实时状况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用快捷键&lt;/p&gt;
&lt;p&gt;下面是 F1~F10 的功能和对应的字母快捷键。
&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    Shortcut Key
&lt;/td&gt;
&lt;td&gt;
    Function Key
&lt;/td&gt;
&lt;td&gt;
    Description
&lt;/td&gt;
&lt;td&gt;
    中文说明
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    h, ?
&lt;/td&gt;
&lt;td&gt;
    F1
&lt;/td&gt;
&lt;td&gt;
    Invoke htop Help
&lt;/td&gt;
&lt;td&gt;
    查看htop使用说明
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    S
&lt;/td&gt;
&lt;td&gt;
    F2
&lt;/td&gt;
&lt;td&gt;
    Htop Setup Menu
&lt;/td&gt;
&lt;td&gt;
    htop 设定
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    /
&lt;/td&gt;
&lt;td&gt;
    F3
&lt;/td&gt;
&lt;td&gt;
    Search for a Process
&lt;/td&gt;
&lt;td&gt;
    搜索进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    \
&lt;/td&gt;
&lt;td&gt;
    F4
&lt;/td&gt;
&lt;td&gt;
    Incremental process filtering
&lt;/td&gt;
&lt;td&gt;
    增量进程过滤器
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    t
&lt;/td&gt;
&lt;td&gt;
    F5
&lt;/td&gt;
&lt;td&gt;
    Tree View
&lt;/td&gt;
&lt;td&gt;
    显示树形结构
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    ,
&lt;/td&gt;
&lt;td&gt;
    F6
&lt;/td&gt;
&lt;td&gt;
    Sort by a column
&lt;/td&gt;
&lt;td&gt;
    选择排序方式
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    [
&lt;/td&gt;
&lt;td&gt;
    F7
&lt;/td&gt;
&lt;td&gt;
    Nice – (change priority)
&lt;/td&gt;
&lt;td&gt;
    可减少nice值，这样就可以提高对应进程的优先级
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    ]
&lt;/td&gt;
&lt;td&gt;
    F8
&lt;/td&gt;
&lt;td&gt;
    Nice + (change priority)
&lt;/td&gt;
&lt;td&gt;
    可增加nice值，这样就可以降低对应进程的优先级
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    k
&lt;/td&gt;
&lt;td&gt;
    F9
&lt;/td&gt;
&lt;td&gt;
    Kill a Process
&lt;/td&gt;
&lt;td&gt;
    可对进程传递信号
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    q
&lt;/td&gt;
&lt;td&gt;
    F10
&lt;/td&gt;
&lt;td&gt;
    Quit htop
&lt;/td&gt;
&lt;td&gt;
    结束htop
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行选项（&lt;span class="caps"&gt;COMMAND&lt;/span&gt;-&lt;span class="caps"&gt;LINE&lt;/span&gt; &lt;span class="caps"&gt;OPTIONS&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    -C –no-color
&lt;/td&gt;
&lt;td&gt;
    使用一个单色的配色方案
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -d –delay=&lt;span class="caps"&gt;DELAY&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    设置延迟更新时间，单位秒
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -h –help
&lt;/td&gt;
&lt;td&gt;
    显示htop 命令帮助信息
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -u –user=&lt;span class="caps"&gt;USERNAME&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    只显示一个给定的用户的过程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -p –pid=&lt;span class="caps"&gt;PID&lt;/span&gt;,&lt;span class="caps"&gt;PID&lt;/span&gt;…
&lt;/td&gt;
&lt;td&gt;
    只显示给定的PIDs
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -s –sort-key &lt;span class="caps"&gt;COLUMN&lt;/span&gt;
&lt;/td&gt;
&lt;td&gt;
    依此列来排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    -v –version
&lt;/td&gt;
&lt;td&gt;
    显示版本信息
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交互式命令（&lt;span class="caps"&gt;INTERACTIVE&lt;/span&gt; &lt;span class="caps"&gt;COMMANDS&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;table class="table table-striped table-bordered table-hover table-condensed"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
    上下键或PgUP, PgDn
&lt;/td&gt;
&lt;td&gt;
    选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Space
&lt;/td&gt;
&lt;td&gt;
    标记/取消标记一个进程。命令可以作用于多个进程，例如 “kill”，将应用于所有已标记的进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    U
&lt;/td&gt;
&lt;td&gt;
    取消标记所有进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    s
&lt;/td&gt;
&lt;td&gt;
    选择某一进程，按s:用strace追踪进程的系统调用
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    l
&lt;/td&gt;
&lt;td&gt;
    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    I
&lt;/td&gt;
&lt;td&gt;
    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    +, -
&lt;/td&gt;
&lt;td&gt;
    在树形模式下，展开或折叠子树
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    a (在有多处理器的机器上)
&lt;/td&gt;
&lt;td&gt;
    设置 &lt;span class="caps"&gt;CPU&lt;/span&gt; affinity: 标记一个进程允许使用哪些&lt;span class="caps"&gt;CPU&lt;/span&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    u
&lt;/td&gt;
&lt;td&gt;
    显示特定用户进程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    M
&lt;/td&gt;
&lt;td&gt;
    按Memory使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    P
&lt;/td&gt;
&lt;td&gt;
    按&lt;span class="caps"&gt;CPU&lt;/span&gt;使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    T
&lt;/td&gt;
&lt;td&gt;
    按Time+使用排序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    F
&lt;/td&gt;
&lt;td&gt;
    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    K
&lt;/td&gt;
&lt;td&gt;
    显示/隐藏内核线程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    H
&lt;/td&gt;
&lt;td&gt;
    显示/隐藏用户线程
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Ctrl-L
&lt;/td&gt;
&lt;td&gt;
    刷新
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
    Numbers
&lt;/td&gt;
&lt;td&gt;
    &lt;span class="caps"&gt;PID&lt;/span&gt; 查找: 输入&lt;span class="caps"&gt;PID&lt;/span&gt;，光标将移动到相应的进程上
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替代top&lt;/p&gt;
&lt;p&gt;用htop替换top，可添加别名，编辑/root/.bashrc文件，添加如下代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias top=htop
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;</summary><category term="linux"></category><category term="command"></category><category term="htop"></category></entry><entry><title>uptime</title><link href="http://blog.wiseturtles.com/posts/linux-uptime.html" rel="alternate"></link><updated>2014-12-15T10:08:00+08:00</updated><author><name>crazygit</name></author><id>tag:blog.wiseturtles.com,2014-12-15:posts/linux-uptime.html</id><summary type="html">&lt;h2&gt;用途&lt;/h2&gt;
&lt;p&gt;man&amp;nbsp;page&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;uptime gives a one line display of the following information.  The cur‐
rent time, how long the system has been running,  how  many  users  are
currently  logged  on,  and the system load averages for the past 1, 5,
and 15&amp;nbsp;minutes.&lt;/p&gt;
&lt;p&gt;System load averages is the average number of processes that are either
in a runnable or uninterruptable state.  A process in a runnable  state
is  either  using the &lt;span class="caps"&gt;CPU&lt;/span&gt; or waiting to use the &lt;span class="caps"&gt;CPU&lt;/span&gt;. A process in unin‐
terruptable state is waiting for some I/O access, eg waiting for  disk.
The  averages  are  taken over the three time intervals. Load averages
are not normalized for the number of CPUs in a system, so a load  aver‐
age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4
&lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Load averages are not normalized for the number of CPUs in a system, so a load  aver‐ age  of 1 means a single &lt;span class="caps"&gt;CPU&lt;/span&gt; system is loaded all the time while on a 4 &lt;span class="caps"&gt;CPU&lt;/span&gt; system it means it was idle 75% of the&amp;nbsp;time.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;uptime
10:14:31 up &lt;span class="m"&gt;10&lt;/span&gt; days, 20:55,  &lt;span class="m"&gt;6&lt;/span&gt; users,  load average: 0.28, 0.42, 0.54
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的结果显示的分别是系统的当前时间，运行时间，当前用户数，过去1, 5, 15分钟的系统平均负载
总体来说，值为1时，当只有单个&lt;span class="caps"&gt;CPU&lt;/span&gt;表示已经完全利用，当有４个&lt;span class="caps"&gt;CPU&lt;/span&gt;时，表示还有75%的空闲.&lt;/p&gt;
&lt;p&gt;关于平均负载的值可以阅读&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages"&gt;http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="command"></category><category term="uptime"></category></entry></feed>